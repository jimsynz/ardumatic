require "busted.runner"
local Angle = require("angle")
local Chain = require("chain")
local Joint = require("joint")
local Link = require "link"
local Object = require("object")
local Vec3 = require("vec3")

describe("Chain.new", function()
  local chain

  before_each(function()
    local position = Vec3.new(1, 1, 1)
    local rotation = Vec3.new(0, 1,1)
    chain = Chain.new()
  end)

  it("creates an instance", function()
    Object.assert_type(chain, Chain)
  end)
end)

describe("Chain:add", function()
  local chain
  before_each(function()
    chain = Chain.new()
  end)

  describe("when adding the the first part", function()
    before_each(function()
      assert.are.equal(chain:length(), 0)
    end)

    describe("when the first part is a joint", function()
      it("adds it to the chain", function()
        local joint = Joint.hinge(Vec3.new(0, 0, 1), Vec3.new(1, 0, 0))
        chain:add(joint)

        assert.are.equal(chain:length(), 1)
      end)
    end)

    describe("when the first part is a link", function()
      it("raises an exception", function()
        assert.has.errors(function()
          chain:add(Link.new(10))
        end)
      end)
    end)
  end)

  describe("when adding subsequent parts", function()
    describe("when the previous part is a link", function()
      before_each(function()
        chain:add(Joint.ball(Vec3.new(0, 0, 1)))
        chain:add(Link.new(13))
      end)

      describe("when trying to add a link", function()
        it("raises an exception", function()
          assert.has.errors(function()
            chain:add(Link.new(13))
          end)
        end)
      end)

      describe("when trying to add a joint", function()
        it("adds it to the chain", function()
          chain:add(Joint.ball(Vec3.new(0, 0, 1), Angle.from_degrees(30)))

          assert.are.equal(chain:length(), 3)
        end)
      end)
    end)

    describe("when the previous part is the joint", function()
      before_each(function()
        chain:add(Joint.ball(Vec3.new(0, 0, 1), Angle.from_degrees(30)))
      end)

      describe("when trying to add a link", function()
        it("adds it to the chain", function()
          chain:add(Link.new(13))

          assert.are.equal(chain:length(), 2)
        end)
      end)

      describe("when trying to add a joint", function()
        it("raises an exception", function()
          assert.has.errors(function()
            chain:add(Joint.ball(Vec3.new(0, 0, 1), Angle.from_degrees(30)))
          end)
        end)
      end)
    end)
  end)
end)

describe("Chain:end_location", function()
  it("returns the position at the end of the chain", function()
    local v0 = Vec3.new(3, 4, 12)
    local v1 = Vec3.new(3, -4, -12)
    local l0 = Link.new(v0:length())
    local l1 = Link.new(v1:length())
    local j0 = Joint.ball(v0)
    local j1 = Joint.ball(v1)
    local chain = Chain.new():add(j0):add(l0):add(j1):add(l1)

    local p = chain:end_location()
    assert.are.equal(p:x(), 6)
    assert.are.equal(p:y(), 0)
    assert.are.equal(p:z(), 0)
  end)
end)

describe("Chain:link_location", function()
  local chain

  before_each(function()
    local v0 = Vec3.new(3, 4, 12)
    local v1 = Vec3.new(3, -4, -12)
    local l0 = Link.new(v0:length())
    local l1 = Link.new(v1:length())
    local j0 = Joint.ball(v0)
    local j1 = Joint.ball(v1)
    chain = Chain.new():add(j0):add(l0):add(j1):add(l1)
  end)

  describe("when the link number is not positive", function()
    it("raises an exception", function()
      assert.has.errors(function()
        chain:part_location(0)
      end)
    end)
  end)

  describe("when the link number is greater than the number of links", function()
    it("raises an exception", function()
      assert.has.errors(function()
        chain:part_location(3)
      end)
    end)
  end)

  describe("when getting the location of the first link", function()
    it("returns the end location of the first link", function()
      local link_location = chain:link_location(1)
      assert.are.equal(link_location:x(), 3)
      assert.are.equal(link_location:y(), 4)
      assert.are.equal(link_location:z(), 12)
    end)
  end)

  describe("when getting the location of the second link", function()
    it("returns the end location of the first link", function()
      local link_location = chain:link_location(2)
      assert.are.equal(link_location:x(), 6)
      assert.are.equal(link_location:y(), 0)
      assert.are.equal(link_location:z(), 0)
    end)
  end)
end)

describe("Chain:forwards", function()
  it("iterates forwards through the chain", function()
    local joint = Joint.ball(Vec3.new(0, 0, 1))
    local link = Link.new(13)
    local chain = Chain.new():add(joint):add(link)

    local iter = chain:forwards()
    assert.are.equal(iter(), joint)
    assert.are.equal(iter(), link)
    assert.is_nil(iter())
  end)
end)

describe("Chain:backwards", function()
  it("iterates backwards through the chain", function()
    local joint = Joint.ball(Vec3.new(0, 0, 1))
    local link = Link.new(13)
    local chain = Chain.new():add(joint):add(link)

    local iter = chain:backwards()
    assert.are.equal(iter(), link)
    assert.are.equal(iter(), joint)
    assert.is_nil(iter())
  end)
end)

describe("Chain:forward_pairs", function()
  it("it iterates through joint/link pairs", function()
    local j0 = Joint.ball(Vec3.new(0, 0, 1))
    local j1 = Joint.ball(Vec3.new(0, 0, 1))
    local l0 = Link.new(1)
    local l1 = Link.new(2)

    local chain = Chain.new():add(j0):add(l0):add(j1):add(l1)

    local iter = chain:forward_pairs()

    local j, l = iter()
    assert.are.equal(j, j0)
    assert.are.equal(l, l0)
    local j, l = iter()
    assert.are.equal(j, j1)
    assert.are.equal(l, l1)
    assert.is_nil(iter())
  end)
end)

describe("Chain:backward_pairs", function()
  it("it iterates through joint/link pairs from the outside in", function()
    local j0 = Joint.ball(Vec3.new(0, 0, 1))
    local j1 = Joint.ball(Vec3.new(0, 0, 1))
    local l0 = Link.new(1)
    local l1 = Link.new(2)

    local chain = Chain.new():add(j0):add(l0):add(j1):add(l1)

    local iter = chain:backward_pairs()

    local j, l = iter()
    assert.are.equal(j, j1)
    assert.are.equal(l, l1)
    local j, l = iter()
    assert.are.equal(j, j0)
    assert.are.equal(l, l0)
    assert.is_nil(iter())
  end)
end)
